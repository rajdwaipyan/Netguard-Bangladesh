import os
import sys
import time
import json
import random
import logging
import socket
import platform
import threading
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
from datetime import datetime
from collections import Counter

# Check for optional dependencies
try:
    import numpy as np
    NUMPY_AVAILABLE = True
except ImportError:
    NUMPY_AVAILABLE = False

try:
    import matplotlib
    matplotlib.use('TkAgg')
    import matplotlib.pyplot as plt
    from matplotlib.figure import Figure
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    MATPLOTLIB_AVAILABLE = True
except ImportError:
    MATPLOTLIB_AVAILABLE = False

try:
    from sklearn.ensemble import IsolationForest
    SKLEARN_AVAILABLE = True
except ImportError:
    SKLEARN_AVAILABLE = False

# Application constants
APP_NAME = "NetGuard Bangladesh"
VERSION = "1.0.0"
DATA_DIR = os.path.join(os.path.expanduser("~"), ".netguard_bangladesh")
LOG_FILE = os.path.join(DATA_DIR, "netguard.log")
ALERT_SOUNDS_ENABLED = True

# Create data directory if it doesn't exist
if not os.path.exists(DATA_DIR):
    os.makedirs(DATA_DIR)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger(__name__)

# Attack signatures database
ATTACK_SIGNATURES = {
    "dos_icmp_flood": {
        "name": "ICMP Flood",
        "description": "Excessive ICMP packets targeting router",
        "severity": "High",
        "detection_pattern": "High ping latency with packet loss",
        "bd_prevalence": "Medium"
    },
    "dos_udp_flood": {
        "name": "UDP Flood",
        "description": "Overwhelming UDP traffic to router ports",
        "severity": "High",
        "detection_pattern": "Router unresponsive to non-UDP traffic",
        "bd_prevalence": "Medium"
    },
    "dns_hijack": {
        "name": "DNS Hijacking",
        "description": "Router DNS settings modified to redirect traffic",
        "severity": "Critical",
        "detection_pattern": "Changed DNS server IPs",
        "bd_prevalence": "High"
    },
    "arp_spoofing": {
        "name": "ARP Spoofing",
        "description": "ARP table manipulation to intercept traffic",
        "severity": "High",
        "detection_pattern": "Multiple MAC addresses for same IP",
        "bd_prevalence": "Medium"
    },
    "deauth_attack": {
        "name": "WiFi Deauthentication",
        "description": "Forced disconnection of WiFi clients",
        "severity": "Medium",
        "detection_pattern": "Multiple unexpected disconnections",
        "bd_prevalence": "High"
    },
    "port_scan": {
        "name": "Port Scanning",
        "description": "Systematic scan of router ports",
        "severity": "Low",
        "detection_pattern": "Sequential port connection attempts",
        "bd_prevalence": "Very High"
    },
    "admin_login_attempt": {
        "name": "Admin Login Attempt",
        "description": "Attempt to access router admin interface",
        "severity": "Medium",
        "detection_pattern": "Multiple admin page requests",
        "bd_prevalence": "High"
    },
    "upnp_exploit": {
        "name": "UPnP Exploitation",
        "description": "Attempt to abuse UPnP functionality",
        "severity": "Medium",
        "detection_pattern": "Unusual UPnP port forwarding",
        "bd_prevalence": "Medium"
    },
    "dns_cache_poison": {
        "name": "DNS Cache Poisoning",
        "description": "Insertion of false DNS records",
        "severity": "High",
        "detection_pattern": "Unexpected DNS resolutions",
        "bd_prevalence": "Medium"
    },
    "wps_pin_attempt": {
        "name": "WPS PIN Brute Force",
        "description": "Attempts to guess WPS PIN code",
        "severity": "Medium",
        "detection_pattern": "Multiple WPS connection attempts",
        "bd_prevalence": "High"
    }
}

# Bangladesh ISP database
BD_ISP_DATABASE = {
    "Grameenphone": {
        "name": "Grameenphone",
        "info": {
            "type": "Mobile + Fixed",
            "coverage": "Nationwide",
            "typical_speed": "10-30 Mbps",
            "common_routers": ["Huawei B315", "ZTE MF253", "TP-Link"],
            "known_vulnerabilities": [
                "Default admin passwords",
                "Outdated firmware",
                "WPS vulnerabilities"
            ]
        }
    },
    "Robi": {
        "name": "Robi Axiata",
        "info": {
            "type": "Mobile + Fixed",
            "coverage": "Nationwide",
            "typical_speed": "8-25 Mbps",
            "common_routers": ["Huawei B310", "ZTE MF283", "D-Link"],
            "known_vulnerabilities": [
                "UPnP vulnerabilities",
                "Default passwords",
                "DNS configuration issues"
            ]
        }
    },
    "Banglalink": {
        "name": "Banglalink",
        "info": {
            "type": "Mobile + Fixed",
            "coverage": "Nationwide",
            "typical_speed": "5-20 Mbps",
            "common_routers": ["Huawei", "ZTE", "Generic OEM"],
            "known_vulnerabilities": [
                "Default passwords",
                "Remote management enabled",
                "Outdated firmware"
            ]
        }
    },
    "BTCL": {
        "name": "Bangladesh Telecommunications Company Ltd.",
        "info": {
            "type": "Fixed Broadband",
            "coverage": "Urban Centers",
            "typical_speed": "5-15 Mbps",
            "common_routers": ["TP-Link", "D-Link", "Tenda"],
            "known_vulnerabilities": [
                "Outdated firmware",
                "Telnet enabled",
                "Weak WiFi encryption"
            ]
        }
    },
    "Link3": {
        "name": "Link3 Technologies",
        "info": {
            "type": "Fixed Broadband",
            "coverage": "Major Cities",
            "typical_speed": "20-50 Mbps",
            "common_routers": ["MikroTik", "TP-Link", "Cisco"],
            "known_vulnerabilities": [
                "RouterOS exploits",
                "Default credentials",
                "Open ports"
            ]
        }
    },
    "Amber IT": {
        "name": "Amber IT",
        "info": {
            "type": "Fixed Broadband",
            "coverage": "Dhaka + Major Cities",
            "typical_speed": "25-100 Mbps",
            "common_routers": ["MikroTik", "TP-Link", "Custom OEM"],
            "known_vulnerabilities": [
                "Default credentials",
                "MikroTik vulnerabilities",
                "Open management ports"
            ]
        }
    },
    "BdCom": {
        "name": "Bangladesh Communications",
        "info": {
            "type": "Fixed Broadband",
            "coverage": "Dhaka + Selected Areas",
            "typical_speed": "10-40 Mbps",
            "common_routers": ["TP-Link", "D-Link", "Tenda"],
            "known_vulnerabilities": [
                "Admin interface exposure",
                "Default credentials",
                "UPnP vulnerabilities"
            ]
        }
    }
}


class NetworkAnalyzer:
    """Analyzes network traffic and detects potential attacks"""
    
    def __init__(self):
        """Initialize the analyzer"""
        self.router_ip = None
        self.ping_history = []
        self.packet_loss_history = []
        self.response_time_history = []
        self.attack_history = []
        self.device_history = {}
        self.anomaly_detector = None
        self.isp_data = random.choice(list(BD_ISP_DATABASE.values()))
        
        # Load saved data
        self.load_data()
        
        # Initialize anomaly detector if sklearn is available
        if SKLEARN_AVAILABLE and len(self.ping_history) > 10:
            self.initialize_anomaly_detector()
            
    def set_router_ip(self, ip):
        """Set the router IP address to monitor"""
        self.router_ip = ip
        logger.info(f"Router IP set to {ip}")
        
    def initialize_anomaly_detector(self):
        """Initialize the machine learning anomaly detector"""
        if not SKLEARN_AVAILABLE:
            logger.warning("Scikit-learn not available, skipping anomaly detector initialization")
            return
            
        try:
            # Prepare data for training
            if len(self.ping_history) > 10:
                # Create feature matrix from ping history
                features = []
                for i in range(len(self.ping_history) - 5):
                    window = self.ping_history[i:i+5]
                    features.append([
                        max(window),             # Max ping
                        min(window),             # Min ping
                        sum(window) / len(window), # Average ping
                        window[-1] - window[0],  # Trend
                        max(window) - min(window) # Range
                    ])
                    
                # Convert to numpy array if available
                if NUMPY_AVAILABLE:
                    features = np.array(features)
                    
                # Train anomaly detector
                self.anomaly_detector = IsolationForest(
                    n_estimators=100,
                    contamination=0.05,
                    random_state=42
                )
                self.anomaly_detector.fit(features)
                
                logger.info("Anomaly detector initialized with historical data")
            else:
                logger.warning("Not enough ping history for anomaly detector initialization")
        except Exception as e:
            logger.error(f"Failed to initialize anomaly detector: {str(e)}")
        
    def analyze_ping(self, ping_time, packet_loss):
        """Analyze a ping response for security anomalies"""
        # Add to history
        self.ping_history.append(ping_time)
        self.packet_loss_history.append(packet_loss)
        
        # Keep history at reasonable size
        max_history = 1000
        if len(self.ping_history) > max_history:
            self.ping_history = self.ping_history[-max_history:]
            self.packet_loss_history = self.packet_loss_history[-max_history:]
            
        # Simple rule-based detection
        threat_indicators = []
        
        # Check for high ping (potential DoS)
        if ping_time > 200:  # Adjust threshold for Bangladesh networks
            threat_indicators.append({
                "type": "high_ping",
                "value": ping_time,
                "threshold": 200
            })
            
        # Check for packet loss (potential attack)
        if packet_loss > 10:  # 10% packet loss threshold
            threat_indicators.append({
                "type": "packet_loss",
                "value": packet_loss,
                "threshold": 10
            })
            
        # Pattern detection for ping spikes
        if len(self.ping_history) >= 5:
            recent_pings = self.ping_history[-5:]
            avg_ping = sum(recent_pings) / len(recent_pings)
            
            # Sudden spike detection
            if ping_time > avg_ping * 3 and ping_time > 150:
                threat_indicators.append({
                    "type": "ping_spike",
                    "value": ping_time,
                    "avg": avg_ping
                })
                
        # ML-based anomaly detection if available
        if SKLEARN_AVAILABLE and self.anomaly_detector and len(self.ping_history) >= 10:
            try:
                # Create feature vector from recent history
                recent_pings = self.ping_history[-5:]
                features = [[
                    max(recent_pings),
                    min(recent_pings),
                    sum(recent_pings) / len(recent_pings),
                    recent_pings[-1] - recent_pings[0],
                    max(recent_pings) - min(recent_pings)
                ]]
                
                # Convert to numpy array if available
                if NUMPY_AVAILABLE:
                    features = np.array(features)
                    
                # Predict anomaly (-1 is anomaly, 1 is normal)
                prediction = self.anomaly_detector.predict(features)[0]
                
                if prediction == -1:
                    threat_indicators.append({
                        "type": "ml_anomaly",
                        "value": "Unusual network pattern detected"
                    })
            except Exception as e:
                logger.error(f"Error in ML anomaly detection: {str(e)}")
                
        # Determine if this indicates an attack
        attack_detected = self.determine_attack(threat_indicators)
        
        return {
            "indicators": threat_indicators,
            "attack_detected": attack_detected
        }
        
    def determine_attack(self, indicators):
        """Determine if threat indicators suggest an attack"""
        if not indicators:
            return None
            
        # Simple detection logic - can be expanded
        # DoS detection
        high_ping_indicator = next((i for i in indicators if i["type"] == "high_ping"), None)
        packet_loss_indicator = next((i for i in indicators if i["type"] == "packet_loss"), None)
        
        if high_ping_indicator and packet_loss_indicator:
            # High ping + packet loss = likely DoS
            attack = {
                "type": "dos_icmp_flood",
                "severity": "High",
                "timestamp": datetime.now().isoformat(),
                "details": f"High ping ({high_ping_indicator['value']}ms) with significant packet loss ({packet_loss_indicator['value']}%)",
                "confidence": 0.8
            }
            self.record_attack(attack)
            return attack
            
        # Ping spike anomaly
        ping_spike = next((i for i in indicators if i["type"] == "ping_spike"), None)
        ml_anomaly = next((i for i in indicators if i["type"] == "ml_anomaly"), None)
        
        if ping_spike and ml_anomaly:
            # Spike + ML anomaly = likely attack
            attack = {
                "type": "dos_udp_flood",
                "severity": "Medium",
                "timestamp": datetime.now().isoformat(),
                "details": f"Sudden ping spike ({ping_spike['value']}ms) with unusual network pattern",
                "confidence": 0.7
            }
            self.record_attack(attack)
            return attack
            
        # Just packet loss
        if packet_loss_indicator and packet_loss_indicator["value"] > 30:
            attack = {
                "type": "deauth_attack",
                "severity": "Medium",
                "timestamp": datetime.now().isoformat(),
                "details": f"Significant packet loss ({packet_loss_indicator['value']}%) indicating possible interference",
                "confidence": 0.6
            }
            self.record_attack(attack)
            return attack
            
        # Just ML anomaly
        if ml_anomaly:
            # Low confidence anomaly
            return {
                "type": "unknown",
                "severity": "Low",
                "timestamp": datetime.now().isoformat(),
                "details": "Unusual network pattern detected by ML model",
                "confidence": 0.4
            }
            
        # No clear attack pattern
        return None
        
    def record_attack(self, attack):
        """Record an attack in the history"""
        logger.warning(f"Attack detected: {attack['type']} ({attack['severity']})")
        self.attack_history.append(attack)
        self.save_data()
        
    def update_device_history(self, devices):
        """Update the history of devices seen on the network"""
        current_time = datetime.now().isoformat()
        
        for device in devices:
            ip = device['ip']
            mac = device['mac']
            
            if ip not in self.device_history:
                # New device
                self.device_history[ip] = {
                    'ip': ip,
                    'mac': mac,
                    'first_seen': current_time,
                    'last_seen': current_time,
                    'appearance_count': 1
                }
            else:
                # Update existing device
                self.device_history[ip]['last_seen'] = current_time
                self.device_history[ip]['appearance_count'] += 1
                
                # Check if MAC changed (potential spoofing)
                if self.device_history[ip]['mac'] != mac:
                    # Record suspicious MAC change
                    attack = {
                        "type": "arp_spoofing",
                        "severity": "High",
                        "timestamp": current_time,
                        "source_ip": ip,
                        "details": f"MAC address changed from {self.device_history[ip]['mac']} to {mac}",
                        "confidence": 0.9
                    }
                    self.record_attack(attack)
                    
                    # Update MAC
                    self.device_history[ip]['mac'] = mac
                    
        self.save_data()
        
    def simulate_random_attack(self):
        """Simulate a random attack for demonstration purposes"""
        # Pick a random attack type
        attack_type = random.choice(list(ATTACK_SIGNATURES.keys()))
        
        # Create attack record
        attack = {
            "type": attack_type,
            "severity": ATTACK_SIGNATURES[attack_type]["severity"],
            "timestamp": datetime.now().isoformat(),
            "details": ATTACK_SIGNATURES[attack_type]["description"],
            "confidence": random.uniform(0.6, 0.95)
        }
        
        # Add random source IP (excluding local network devices)
        external_ip = f"175.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        attack["source_ip"] = external_ip
        
        self.record_attack(attack)
        return attack
        
    def load_data(self):
        """Load history and settings from disk"""
        try:
            # Load attack history
            history_file = os.path.join(DATA_DIR, "attack_history.json")
            if os.path.exists(history_file):
                with open(history_file, 'r') as f:
                    data = json.load(f)
                    self.attack_history = data.get('attacks', [])
                    self.ping_history = data.get('pings', [])
                    self.packet_loss_history = data.get('packet_loss', [])
                    self.device_history = data.get('devices', {})
                    
                    # Load ISP data if available
                    isp_name = data.get('isp_name')
                    if isp_name and isp_name in BD_ISP_DATABASE:
                        self.isp_data = BD_ISP_DATABASE[isp_name]
                        
            logger.info(f"Loaded {len(self.attack_history)} historical attacks")
        except Exception as e:
            logger.error(f"Failed to load data: {str(e)}")
            
    def save_data(self):
        """Save history and settings to disk"""
        try:
            # Ensure directory exists
            if not os.path.exists(DATA_DIR):
                os.makedirs(DATA_DIR)
                
            # Prepare data
            data = {
                'attacks': self.attack_history,
                'pings': self.ping_history,
                'packet_loss': self.packet_loss_history,
                'devices': self.device_history,
                'isp_name': self.isp_data['name']
            }
            
            # Save to file
            history_file = os.path.join(DATA_DIR, "attack_history.json")
            with open(history_file, 'w') as f:
                json.dump(data, f, indent=2)
                
            logger.debug("Saved analyzer data to disk")
        except Exception as e:
            logger.error(f"Failed to save data: {str(e)}")


class NetGuardBangladesh:
    """Main application class for NetGuard Bangladesh"""
    
    def __init__(self, root):
        """Initialize the application"""
        self.root = root
        self.root.title(f"{APP_NAME} v{VERSION}")
        self.root.geometry("900x650")
        self.root.minsize(800, 600)
        
        # Set app icon if available
        # self.root.iconbitmap("icon.ico")  # Uncomment and provide icon
        
        # Initialize variables
        self.is_monitoring = tk.BooleanVar(value=False)
        self.router_ip = tk.StringVar(value="192.168.0.1")  # Default router IP
        self.is_dark_mode = tk.BooleanVar(value=False)
        self.scan_interval = tk.IntVar(value=30)  # seconds
        self.alert_level = tk.StringVar(value="Medium")
        self.ping_status = tk.StringVar(value="Not monitoring")
        self.packet_loss = tk.DoubleVar(value=0.0)
        self.router_status = tk.StringVar(value="Unknown")
        self.attack_status = tk.StringVar(value="No threats detected")
        self.device_list = []
        self.last_device_scan = None
        
        # Load preferences
        self.load_preferences()
        
        # Apply theme
        self.apply_theme()
        
        # Create network analyzer
        self.network_analyzer = NetworkAnalyzer()
        self.network_analyzer.set_router_ip(self.router_ip.get())
        
        # Create UI
        self.create_menu()
        self.create_dashboard()
        
        # Start automatic refreshing
        self.update_status()
        
    def create_menu(self):
        """Create the application menu"""
        menubar = tk.Menu(self.root)
        
        # File menu
        file_menu = tk.Menu(menubar, tearoff=0)
        file_menu.add_command(label="Preferences", command=self.show_preferences)
        file_menu.add_separator()
        file_menu.add_command(label="Exit", command=self.on_close)
        menubar.add_cascade(label="File", menu=file_menu)
        
        # Tools menu
        tools_menu = tk.Menu(menubar, tearoff=0)
        tools_menu.add_command(label="Network Map", command=self.show_network_map)
        tools_menu.add_command(label="Network Devices", command=self.show_network_devices)
        tools_menu.add_command(label="Router Vulnerability Scan", command=self.scan_router_vulnerabilities)
        tools_menu.add_command(label="Internet Speed Test", command=self.run_speed_test)
        tools_menu.add_command(label="Attack History", command=self.show_attack_history)
        menubar.add_cascade(label="Tools", menu=tools_menu)
        
        # Alert menu
        alert_menu = tk.Menu(menubar, tearoff=0)
        alert_menu.add_command(label="Alert Settings", command=self.show_alert_settings)
        menubar.add_cascade(label="Alerts", menu=alert_menu)
        
        # Help menu
        help_menu = tk.Menu(menubar, tearoff=0)
        help_menu.add_command(label="Tutorial", command=self.show_tutorial)
        help_menu.add_command(label="Bangladesh Network Security Info", command=self.show_bd_security_info)
        help_menu.add_separator()
        help_menu.add_command(label="About", command=self.show_about)
        menubar.add_cascade(label="Help", menu=help_menu)
        
        self.root.config(menu=menubar)
        
    def create_dashboard(self):
        """Create the main dashboard interface"""
        # Create main frame with padding
        main_frame = ttk.Frame(self.root, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create header frame
        header_frame = ttk.Frame(main_frame)
        header_frame.pack(fill=tk.X, pady=(0, 10))
        
        # App title
        ttk.Label(
            header_frame,
            text=APP_NAME,
            font=("Arial", 20, "bold")
        ).pack(side=tk.LEFT)
        
        # Version
        ttk.Label(
            header_frame,
            text=f"v{VERSION}",
            font=("Arial", 10)
        ).pack(side=tk.LEFT, padx=5, pady=8)
        
        # Status indicator
        self.status_indicator = ttk.Label(
            header_frame,
            text="●",
            font=("Arial", 18),
            foreground="gray"
        )
        self.status_indicator.pack(side=tk.RIGHT, padx=5)
        
        # Control frame
        control_frame = ttk.LabelFrame(main_frame, text="Network Controls", padding=10)
        control_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Control grid
        control_grid = ttk.Frame(control_frame)
        control_grid.pack(fill=tk.X, padx=5, pady=5)
        
        # Router IP
        ttk.Label(control_grid, text="Router IP:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        ttk.Entry(
            control_grid,
            textvariable=self.router_ip,
            width=15
        ).grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        # ISP display
        ttk.Label(control_grid, text="ISP:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)
        ttk.Label(
            control_grid,
            text=self.network_analyzer.isp_data['name']
        ).grid(row=0, column=3, sticky=tk.W, padx=5, pady=5)
        
        # Change ISP button
        ttk.Button(
            control_grid,
            text="Change",
            width=8,
            command=self.select_isp
        ).grid(row=0, column=4, padx=5, pady=5)
        
        # Buttons
        button_frame = ttk.Frame(control_frame)
        button_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Start/Stop monitoring
        self.monitor_button = ttk.Button(
            button_frame,
            text="Start Monitoring",
            command=self.toggle_monitoring
        )
        self.monitor_button.pack(side=tk.LEFT, padx=5)
        
        # Scan devices button
        ttk.Button(
            button_frame,
            text="Scan Network Devices",
            command=self.scan_devices
        ).pack(side=tk.LEFT, padx=5)
        
        # Scan vulnerabilities button
        ttk.Button(
            button_frame,
            text="Scan Vulnerabilities",
            command=self.scan_router_vulnerabilities
        ).pack(side=tk.LEFT, padx=5)
        
        # Test connection button
        ttk.Button(
            button_frame,
            text="Test Connection",
            command=self.test_connection
        ).pack(side=tk.LEFT, padx=5)
        
        # Status frame
        status_frame = ttk.LabelFrame(main_frame, text="Network Status", padding=10)
        status_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Status grid
        status_grid = ttk.Frame(status_frame)
        status_grid.pack(fill=tk.X, padx=5, pady=5)
        
        # Router status
        ttk.Label(status_grid, text="Router:").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)
        ttk.Label(
            status_grid,
            textvariable=self.router_status,
            width=15
        ).grid(row=0, column=1, sticky=tk.W, padx=5, pady=5)
        
        # Ping status
        ttk.Label(status_grid, text="Ping:").grid(row=0, column=2, sticky=tk.W, padx=5, pady=5)
        ttk.Label(
            status_grid,
            textvariable=self.ping_status,
            width=15
        ).grid(row=0, column=3, sticky=tk.W, padx=5, pady=5)
        
        # Packet loss
        ttk.Label(status_grid, text="Packet Loss:").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)
        ttk.Label(
            status_grid,
            textvariable=self.packet_loss,
            width=15
        ).grid(row=1, column=1, sticky=tk.W, padx=5, pady=5)
        
        # Attack status
        ttk.Label(status_grid, text="Security:").grid(row=1, column=2, sticky=tk.W, padx=5, pady=5)
        ttk.Label(
            status_grid,
            textvariable=self.attack_status,
            width=25
        ).grid(row=1, column=3, sticky=tk.W, padx=5, pady=5)
        
        # Create ping chart if matplotlib available
        if MATPLOTLIB_AVAILABLE:
            chart_frame = ttk.LabelFrame(main_frame, text="Network Monitoring", padding=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            # Set up the figure
            self.fig = Figure(figsize=(5, 3), dpi=100)
            self.ax = self.fig.add_subplot(111)
            self.ax.set_title('Router Response Time')
            self.ax.set_xlabel('Time')
            self.ax.set_ylabel('Ping (ms)')
            self.ax.grid(True)
            
            # Empty plot to start
            self.line, = self.ax.plot([], [], 'b-')
            
            # Add to UI
            self.canvas = FigureCanvasTkAgg(self.fig, master=chart_frame)
            self.canvas.draw()
            self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        else:
            # Alternative if matplotlib not available
            chart_frame = ttk.LabelFrame(main_frame, text="Network Monitoring", padding=10)
            chart_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
            
            ttk.Label(
                chart_frame,
                text="Install matplotlib for visualization",
                font=("Arial", 12)
            ).pack(pady=50)
        
        # Log frame
        log_frame = ttk.LabelFrame(main_frame, text="Security Log", padding=10)
        log_frame.pack(fill=tk.BOTH, expand=True)
        
        # Log text widget
        self.log_text = scrolledtext.ScrolledText(
            log_frame,
            wrap=tk.WORD,
            height=6,
            font=("Consolas", 9)
        )
        self.log_text.pack(fill=tk.BOTH, expand=True)
        self.log_text.config(state=tk.DISABLED)
        
        # Add initial log message
        self.log_message(f"{APP_NAME} v{VERSION} started", "info")
        self.log_message("Monitoring not active", "info")
        
        # Network devices frame
        devices_frame = ttk.LabelFrame(main_frame, text="Connected Devices", padding=10)
        devices_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Device count label
        self.device_count_label = ttk.Label(
            devices_frame,
            text="No devices scanned yet"
        )
        self.device_count_label.pack(anchor=tk.W, padx=5, pady=(0, 5))
        
        # Device list in a treeview
        self.device_tree = ttk.Treeview(
            devices_frame,
            columns=('ip', 'mac', 'type'),
            show='headings',
            height=3
        )
        
        # Define headings
        self.device_tree.heading('ip', text='IP Address')
        self.device_tree.heading('mac', text='MAC Address')
        self.device_tree.heading('type', text='Device Type')
        
        # Define columns
        self.device_tree.column('ip', width=120)
        self.device_tree.column('mac', width=150)
        self.device_tree.column('type', width=100)
        
        # Pack tree
        self.device_tree.pack(fill=tk.X)
        
        # Button to show all devices
        ttk.Button(
            devices_frame,
            text="Show All Devices",
            command=self.show_network_devices
        ).pack(anchor=tk.E, padx=5, pady=5)
        
    def apply_theme(self):
        """Apply light or dark theme to the app"""
        # Style configuration
        style = ttk.Style()
        
        if self.is_dark_mode.get():
            # Dark theme
            self.root.tk_setPalette(
                background='#2e2e2e',
                foreground='#ffffff',
                activeBackground='#4a4a4a',
                activeForeground='#ffffff'
            )
            
            style.configure('TFrame', background='#2e2e2e')
            style.configure('TLabel', background='#2e2e2e', foreground='#ffffff')
            style.configure('TButton', background='#4a4a4a', foreground='#ffffff')
            style.configure('TCheckbutton', background='#2e2e2e', foreground='#ffffff')
            style.configure('TRadiobutton', background='#2e2e2e', foreground='#ffffff')
            
            style.configure('TLabelframe', background='#2e2e2e', foreground='#ffffff')
            style.configure('TLabelframe.Label', background='#2e2e2e', foreground='#ffffff')
            
            # Configure the treeview
            style.configure('Treeview', 
                background='#3e3e3e', 
                foreground='#ffffff',
                fieldbackground='#3e3e3e'
            )
        else:
            # Light theme (default)
            self.root.tk_setPalette(
                background='#f0f0f0',
                foreground='#000000',
                activeBackground='#e0e0e0',
                activeForeground='#000000'
            )
            
            style.configure('TFrame', background='#f0f0f0')
            style.configure('TLabel', background='#f0f0f0', foreground='#000000')
            style.configure('TButton', background='#e0e0e0', foreground='#000000')
            style.configure('TCheckbutton', background='#f0f0f0', foreground='#000000')
            style.configure('TRadiobutton', background='#f0f0f0', foreground='#000000')
            
            style.configure('TLabelframe', background='#f0f0f0', foreground='#000000')
            style.configure('TLabelframe.Label', background='#f0f0f0', foreground='#000000')
            
            # Configure the treeview
            style.configure('Treeview', 
                background='#ffffff', 
                foreground='#000000',
                fieldbackground='#ffffff'
            )
        
    def toggle_monitoring(self):
        """Start or stop monitoring"""
        if not self.is_monitoring.get():
            # Start monitoring
            self.start_monitoring()
        else:
            # Stop monitoring
            self.stop_monitoring()
            
    def start_monitoring(self):
        """Start network monitoring"""
        self.is_monitoring.set(True)
        self.monitor_button.config(text="Stop Monitoring")
        
        # Update router IP in analyzer
        self.network_analyzer.set_router_ip(self.router_ip.get())
        
        # Log start
        self.log_message("Starting network monitoring...", "info")
        
        # Update status
        self.router_status.set("Connecting...")
        self.status_indicator.config(foreground="orange")
        
        # Start monitoring thread
        self.monitoring_thread = threading.Thread(target=self.monitoring_loop)
        self.monitoring_thread.daemon = True
        self.monitoring_thread.start()
        
    def stop_monitoring(self):
        """Stop network monitoring"""
        self.is_monitoring.set(False)
        self.monitor_button.config(text="Start Monitoring")
        
        # Log stop
        self.log_message("Monitoring stopped", "info")
        
        # Update status
        self.router_status.set("Not monitoring")
        self.ping_status.set("Not monitoring")
        self.status_indicator.config(foreground="gray")
        
    def monitoring_loop(self):
        """Main monitoring loop - runs in a separate thread"""
        last_device_scan_time = 0
        
        while self.is_monitoring.get():
            try:
                # Test router connectivity
                ping_result = self.ping_router(self.router_ip.get())
                
                # Update UI with ping results
                self.ping_status.set(f"{ping_result['time']:.1f} ms")
                self.packet_loss.set(ping_result['packet_loss'])
                
                if ping_result['success']:
                    self.router_status.set("Connected")
                    self.status_indicator.config(foreground="green")
                else:
                    self.router_status.set("Error")
                    self.status_indicator.config(foreground="red")
                    self.log_message("Router connectivity error", "error")
                    
                # Analyze for security issues
                if ping_result['success']:
                    analysis = self.network_analyzer.analyze_ping(
                        ping_result['time'],
                        ping_result['packet_loss']
                    )
                    
                    # Check for detected attack
                    if analysis['attack_detected']:
                        attack = analysis['attack_detected']
                        self.attack_status.set(f"⚠️ {ATTACK_SIGNATURES[attack['type']]['name']}")
                        self.status_indicator.config(foreground="red")
                        
                        # Log attack
                        self.log_message(
                            f"Attack detected: {ATTACK_SIGNATURES[attack['type']]['name']} ({attack['severity']})",
                            "alert"
                        )
                        
                        # Show alert if sounds enabled
                        if ALERT_SOUNDS_ENABLED:
                            self.show_attack_alert(attack)
                    elif analysis['indicators']:
                        # Suspicious activity
                        self.attack_status.set("⚠️ Suspicious activity")
                        self.status_indicator.config(foreground="orange")
                    else:
                        # Normal
                        self.attack_status.set("No threats detected")
                        
                # Update chart if matplotlib available
                if MATPLOTLIB_AVAILABLE and hasattr(self, 'ax') and hasattr(self, 'line'):
                    # Update monitoring chart
                    self.update_chart()
                    
                # Periodic device scanning (every 10 minutes)
                current_time = time.time()
                if current_time - last_device_scan_time > 600:  # 10 minutes
                    self.scan_devices()
                    last_device_scan_time = current_time
                    
                # Sleep for interval
                for _ in range(self.scan_interval.get() * 2):
                    time.sleep(0.5)
                    if not self.is_monitoring.get():
                        break
                        
            except Exception as e:
                logger.error(f"Error in monitoring loop: {str(e)}")
                self.log_message(f"Monitoring error: {str(e)}", "error")
                time.sleep(5)  # Wait before retry
                
    def ping_router(self, ip):
        """Ping the router and return statistics"""
        # In a real implementation, this would use actual ping
        # For demonstration, we'll simulate realistic responses
        
        try:
            # Simulate network conditions
            if random.random() < 0.05:
                # Simulate occasional timeout
                return {
                    'success': False,
                    'time': 0,
                    'packet_loss': 100.0
                }
                
            # Generate realistic ping time for Bangladesh networks
            base_ping = 5  # Base latency
            variation = random.uniform(0, 15)  # Random variation
            
            # Add occasional spikes (1% chance)
            if random.random() < 0.01:
                variation += random.uniform(50, 200)
                
            ping_time = base_ping + variation
            
            # Generate packet loss (usually low)
            packet_loss = random.uniform(0, 2)  # Normal is 0-2%
            
            # Occasional packet loss spike (0.5% chance)
            if random.random() < 0.005:
                packet_loss = random.uniform(10, 50)
                
            return {
                'success': True,
                'time': ping_time,
                'packet_loss': packet_loss
            }
            
        except Exception as e:
            logger.error(f"Error pinging router: {str(e)}")
            return {
                'success': False,
                'time': 0,
                'packet_loss': 100.0
            }
            
    def update_chart(self):
        """Update the ping monitoring chart"""
        try:
            # Get ping history
            ping_data = self.network_analyzer.ping_history
            
            if ping_data:
                # Limit to last 100 data points
                ping_data = ping_data[-100:]
                
                # Update chart data
                x_data = list(range(len(ping_data)))
                self.line.set_data(x_data, ping_data)
                
                # Adjust axes
                self.ax.set_xlim(0, max(20, len(ping_data)))
                
                max_ping = max(ping_data) if ping_data else 100
                self.ax.set_ylim(0, max(100, max_ping * 1.1))
                
                # Redraw
                self.canvas.draw()
        except Exception as e:
            logger.error(f"Error updating chart: {str(e)}")
            
    def scan_devices(self):
        """Scan for devices on the network"""
        self.log_message("Scanning for network devices...", "info")
        
        try:
            # In a real implementation, this would use actual network scanning
            # For demonstration, we'll simulate device discovery
            
            # Remember time of scan
            self.last_device_scan = datetime.now()
            
            # Clear existing devices
            self.device_tree.delete(*self.device_tree.get_children())
            
            # Simulate finding devices (includes router)
            router_ip = self.router_ip.get()
            router_mac = "00:1A:2B:3C:4D:5E"  # Simulated MAC
            
            # Create device list
            self.device_list = [
                {'ip': router_ip, 'mac': router_mac}
            ]
            
            # Add simulated devices
            num_devices = random.randint(3, 8)
            for i in range(num_devices):
                # Generate IP in same subnet as router
                ip_parts = router_ip.split('.')
                ip_parts[3] = str(random.randint(2, 254))
                device_ip = '.'.join(ip_parts)
                
                # Generate mock MAC address
                mac_parts = [format(random.randint(0, 255), '02x') for _ in range(6)]
                device_mac = ':'.join(mac_parts)
                
                self.device_list.append({'ip': device_ip, 'mac': device_mac})
                
            # Update device history in analyzer
            self.network_analyzer.update_device_history(self.device_list)
            
            # Update device count
            self.device_count_label.config(text=f"Found {len(self.device_list)} devices")
            
            # Add to treeview
            for device in self.device_list:
                ip = device['ip']
                mac = device['mac']
                
                # Check if this is the router
                is_router = ip == router_ip
                device_type = "Router" if is_router else self.guess_device_type(mac)
                
                self.device_tree.insert('', tk.END, values=(ip, mac, device_type))
                
            self.log_message(f"Found {len(self.device_list)} devices on the network", "info")
            
        except Exception as e:
            logger.error(f"Error scanning devices: {str(e)}")
            self.log_message(f"Device scan error: {str(e)}", "error")
            
    def guess_device_type(self, mac):
        """Guess device type from MAC address"""
        # In a real implementation, this would use the MAC OUI
        # For demonstration, we'll randomize
        
        device_types = [
            "Smartphone", "Laptop", "Smart TV", "IoT Device", 
            "Tablet", "Desktop", "Game Console", "Unknown"
        ]
        
        # Use MAC as a seed for consistent results
        mac_seed = int(mac.replace(':', ''), 16) % 100
        random.seed(mac_seed)
        
        device_type = random.choice(device_types)
        random.seed()  # Reset seed
        
        return device_type
        
    def test_connection(self):
        """Test router connectivity"""
        self.log_message(f"Testing connection to {self.router_ip.get()}...", "info")
        
        # Update status
        self.router_status.set("Testing...")
        
        # Ping router
        ping_result = self.ping_router(self.router_ip.get())
        
        # Update status based on result
        if ping_result['success']:
            self.router_status.set("Connected")
            self.ping_status.set(f"{ping_result['time']:.1f} ms")
            self.packet_loss.set(ping_result['packet_loss'])
            self.status_indicator.config(foreground="green")
            
            self.log_message(
                f"Router is reachable. Ping: {ping_result['time']:.1f} ms, "
                f"Packet loss: {ping_result['packet_loss']:.1f}%",
                "info"
            )
        else:
            self.router_status.set("Unreachable")
            self.ping_status.set("Timeout")
            self.status_indicator.config(foreground="red")
            
            self.log_message("Router is unreachable", "error")
            
            # Show error dialog
            messagebox.showerror(
                "Connection Failed",
                f"Unable to connect to router at {self.router_ip.get()}.\n\n"
                f"Please check the IP address and network connectivity."
            )
            
    def show_attack_alert(self, attack):
        """Show an alert for detected attack"""
        try:
            # Get attack details from signature database
            attack_type = attack['type']
            attack_info = ATTACK_SIGNATURES.get(attack_type, {})
            
            # Create alert window
            alert_window = tk.Toplevel(self.root)
            alert_window.title("⚠️ Security Alert")
            alert_window.geometry("500x350")
            alert_window.grab_set()  # Make modal
            
            # Main frame
            main_frame = ttk.Frame(alert_window, padding=15)
            main_frame.pack(fill=tk.BOTH, expand=True)
            
            # Alert header
            ttk.Label(
                main_frame,
                text="⚠️ Security Threat Detected",
                font=("Arial", 16, "bold"),
                foreground="red"
            ).pack(pady=(0, 10))
            
            # Attack name
            ttk.Label(
                main_frame,
                text=attack_info.get('name', attack_type),
                font=("Arial", 14, "bold")
            ).pack(pady=(0, 20))
            
            # Details frame
            details_frame = ttk.LabelFrame(main_frame, text="Threat Details", padding=10)
            details_frame.pack(fill=tk.X, pady=(0, 10))
            
            # Attack details
            ttk.Label(details_frame, text=f"Type: {attack_info.get('name', attack_type)}").pack(anchor=tk.W, pady=2)
            ttk.Label(details_frame, text=f"Severity: {attack['severity']}").pack(anchor=tk.W, pady=2)
            ttk.Label(details_frame, text=f"Time: {datetime.fromisoformat(attack['timestamp']).strftime('%H:%M:%S')}").pack(anchor=tk.W, pady=2)
            
            if 'source_ip' in attack:
                ttk.Label(details_frame, text=f"Source: {attack['source_ip']}").pack(anchor=tk.W, pady=2)
                
            ttk.Label(details_frame, text=f"Description: {attack_info.get('description', 'Unknown attack type')}").pack(anchor=tk.W, pady=2)
            
            # Bangladesh-specific context
            if 'bd_prevalence' in attack_info:
                bd_frame = ttk.LabelFrame(main_frame, text="Bangladesh Context", padding=10)
                bd_frame.pack(fill=tk.X, pady=(0, 10))
                
                ttk.Label(
                    bd_frame,
                    text=f"Prevalence in Bangladesh: {attack_info['bd_prevalence']}",
                    wraplength=400
                ).pack(anchor=tk.W, pady=2)
                
                # Add additional Bangladesh context based on attack type
                bd_context = ""
                if attack_type == "dns_hijack":
                    bd_context = "DNS hijacking is frequently used in Bangladesh to redirect banking traffic to phishing sites."
                elif attack_type == "deauth_attack":
                    bd_context = "Deauthentication attacks are common in dense urban areas of Bangladesh due to WiFi crowding."
                elif attack_type == "dos_icmp_flood":
                    bd_context = "ICMP flood attacks are increasingly targeting Bangladeshi home networks."
                    
                if bd_context:
                    ttk.Label(
                        bd_frame,
                        text=bd_context,
                        wraplength=400
                    ).pack(anchor=tk.W, pady=2)
                    
            # Recommendation frame
            rec_frame = ttk.LabelFrame(main_frame, text="Recommended Actions", padding=10)
            rec_frame.pack(fill=tk.X, pady=(0, 10))
            
            # Generic recommendation based on attack type
            recommendation = "Monitoring the situation. No immediate action required."
            
            if attack['severity'] == "Critical" or attack['severity'] == "High":
                if attack_type == "dns_hijack":
                    recommendation = "Immediately check router DNS settings and restore default DNS servers."
                elif attack_type == "dos_icmp_flood" or attack_type == "dos_udp_flood":
                    recommendation = "Consider rebooting your router and contacting your ISP if the attack persists."
                elif attack_type == "arp_spoofing":
                    recommendation = "Disconnect suspicious devices and check for unauthorized network access."
                else:
                    recommendation = "Consider rebooting your router and checking for unauthorized devices."
                    
            ttk.Label(
                rec_frame,
                text=recommendation,
                wraplength=400
            ).pack(anchor=tk.W, pady=5)
            
            # Button frame
            button_frame = ttk.Frame(main_frame)
            button_frame.pack(fill=tk.X, pady=(10, 0))
            
            # Dismiss button
            ttk.Button(
                button_frame,
                text="Dismiss",
                command=alert_window.destroy
            ).pack(side=tk.RIGHT, padx=5)
            
            # Details button
            ttk.Button(
                button_frame,
                text="View Details",
                command=lambda: [alert_window.destroy(), self.show_attack_history()]
            ).pack(side=tk.RIGHT, padx=5)
            
        except Exception as e:
            logger.error(f"Error showing attack alert: {str(e)}")
            
    def log_message(self, message, level="info"):
        """Add a message to the log"""
        try:
            # Get current time
            timestamp = datetime.now().strftime("%H:%M:%S")
            
            # Format log message
            if level == "error":
                log_entry = f"[{timestamp}] ERROR: {message}"
                logger.error(message)
            elif level == "alert":
                log_entry = f"[{timestamp}] ALERT: {message}"
                logger.warning(message)
            else:
                log_entry = f"[{timestamp}] INFO: {message}"
                logger.info(message)
                
            # Add to log widget
            self.log_text.config(state=tk.NORMAL)
            self.log_text.insert(tk.END, log_entry + "\n")
            self.log_text.see(tk.END)  # Scroll to end
            self.log_text.config(state=tk.DISABLED)
            
            # Set colors based on message type
            if level == "error":
                self.log_text.tag_add("error", "end-1l linestart", "end-1l lineend")
                self.log_text.tag_config("error", foreground="red")
            elif level == "alert":
                self.log_text.tag_add("alert", "end-1l linestart", "end-1l lineend")
                self.log_text.tag_config("alert", foreground="orange")
                
        except Exception as e:
            # If logging fails, print to console as last resort
            print(f"Logging error: {str(e)}")
            print(f"Original message: {message}")
            
    def select_isp(self):
        """Select ISP for the network"""
        # Create window
        isp_window = tk.Toplevel(self.root)
        isp_window.title("Select ISP")
        isp_window.geometry("400x300")
        isp_window.grab_set()  # Make modal
        
        # Main frame
        main_frame = ttk.Frame(isp_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        ttk.Label(
            main_frame,
            text="Select Your ISP",
            font=("Arial", 14, "bold")
        ).pack(pady=(0, 10))
        
        # ISP listbox
        isp_frame = ttk.Frame(main_frame)
        isp_frame.pack(fill=tk.BOTH, expand=True, pady=(0, 10))
        
        isp_listbox = tk.Listbox(
            isp_frame,
            font=("Arial", 11),
            height=10
        )
        isp_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(isp_frame, orient=tk.VERTICAL, command=isp_listbox.yview)
        isp_listbox.configure(yscroll=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Add ISPs to listbox
        isp_list = list(BD_ISP_DATABASE.keys())
        for isp in sorted(isp_list):
            isp_listbox.insert(tk.END, isp)
            
        # Select current ISP
        current_isp = self.network_analyzer.isp_data['name']
        for i, isp in enumerate(isp_list):
            if BD_ISP_DATABASE[isp]['name'] == current_isp:
                isp_listbox.selection_set(i)
                isp_listbox.see(i)
                break
                
        # Button frame
        button_frame = ttk.Frame(main_frame)
        button_frame.pack(fill=tk.X, pady=(10, 0))
        
        # Cancel button
        ttk.Button(
            button_frame,
            text="Cancel",
            command=isp_window.destroy
        ).pack(side=tk.RIGHT, padx=5)
        
        # Save button
        def save_isp():
            selection = isp_listbox.curselection()
            if selection:
                index = selection[0]
                isp_name = isp_listbox.get(index)
                
                # Update ISP
                self.network_analyzer.isp_data = BD_ISP_DATABASE[isp_name]
                
                # Save to disk
                self.network_analyzer.save_data()
                
                # Log change
                self.log_message(f"ISP changed to {isp_name}", "info")
                
                # Close window
                isp_window.destroy()
                
                # Update UI
                self.update_status()
        
        ttk.Button(
            button_frame,
            text="Save",
            command=save_isp
        ).pack(side=tk.RIGHT, padx=5)
        
    def update_status(self):
        """Update status display"""
        # Update ISP display if applicable
        if hasattr(self, 'network_analyzer') and self.network_analyzer.isp_data:
            for widget in self.root.winfo_children():
                if isinstance(widget, ttk.Frame):
                    for child in widget.winfo_children():
                        if isinstance(child, ttk.Frame):
                            for grandchild in child.winfo_children():
                                if isinstance(grandchild, ttk.Label) and grandchild.cget("text") == "ISP:":
                                    # Find the ISP value label (next sibling)
                                    siblings = child.winfo_children()
                                    for i, sibling in enumerate(siblings):
                                        if sibling == grandchild and i + 1 < len(siblings):
                                            siblings[i+1].config(text=self.network_analyzer.isp_data['name'])
                                            break
        
        # Schedule next update
        self.root.after(5000, self.update_status)
        
    def load_preferences(self):
        """Load user preferences"""
        try:
            preferences_file = os.path.join(DATA_DIR, "preferences.json")
            if os.path.exists(preferences_file):
                with open(preferences_file, 'r') as f:
                    preferences = json.load(f)
                    
                    # Apply preferences
                    if 'scan_interval' in preferences:
                        self.scan_interval.set(preferences['scan_interval'])
                        
                    if 'alert_level' in preferences:
                        self.alert_level.set(preferences['alert_level'])
                        
                    if 'dark_mode' in preferences:
                        self.is_dark_mode.set(preferences['dark_mode'])
                        
                    if 'sound_alerts' in preferences:
                        global ALERT_SOUNDS_ENABLED
                        ALERT_SOUNDS_ENABLED = preferences['sound_alerts']
                        
            logger.info("Preferences loaded")
        except Exception as e:
            logger.error(f"Failed to load preferences: {str(e)}")
            
    def export_attack_history(self):
        """Export attack history to a file"""
        try:
            # Ask for save location
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                title="Export Attack History"
            )
            
            if not file_path:
                return
                
            # Save history
            with open(file_path, 'w') as file:
                file.write("NETGUARD BANGLADESH - ATTACK HISTORY\n")
                file.write("====================================\n\n")
                file.write(f"Export Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                file.write(f"Router IP: {self.router_ip.get()}\n")
                file.write(f"ISP: {self.network_analyzer.isp_data['name']}\n\n")
                file.write(f"Total Attacks Detected: {len(self.network_analyzer.attack_history)}\n\n")
                
                # Write each attack
                for i, attack in enumerate(self.network_analyzer.attack_history, 1):
                    # Get attack details
                    attack_type = attack['type']
                    attack_info = ATTACK_SIGNATURES.get(attack_type, {})
                    
                    # Format timestamp
                    timestamp = datetime.fromisoformat(attack['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
                    
                    file.write(f"Attack #{i}\n")
                    file.write(f"  Time: {timestamp}\n")
                    file.write(f"  Type: {attack_info.get('name', attack_type)}\n")
                    file.write(f"  Severity: {attack['severity']}\n")
                    
                    if 'source_ip' in attack:
                        file.write(f"  Source: {attack['source_ip']}\n")
                        
                    file.write(f"  Description: {attack_info.get('description', 'Unknown attack type')}\n")
                    
                    if 'details' in attack:
                        file.write(f"  Details: {attack['details']}\n")
                        
                    file.write("\n")
                    
            messagebox.showinfo(
                "Export Successful",
                f"Attack history exported to:\n{file_path}"
            )
            
        except Exception as e:
            messagebox.showerror(
                "Export Error",
                f"Failed to export attack history: {str(e)}"
            )
    
    def show_attack_history(self):
        """Show historical attack data"""
        history_window = tk.Toplevel(self.root)
        history_window.title("Attack History")
        history_window.geometry("800x600")
        
        # Create main frame
        main_frame = ttk.Frame(history_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        ttk.Label(
            main_frame,
            text="Attack History",
            font=("Arial", 16, "bold")
        ).pack(pady=(0, 10))
        
        # Create history display
        if not self.network_analyzer.attack_history:
            ttk.Label(
                main_frame,
                text="No attacks have been detected yet.",
                font=("Arial", 12)
            ).pack(pady=50)
            return
        
        # Create a frame for the attack list
        list_frame = ttk.LabelFrame(main_frame, text="Detected Attacks", padding=10)
        list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Create attack list in a treeview
        columns = ('timestamp', 'type', 'severity', 'source', 'details')
        attack_tree = ttk.Treeview(list_frame, columns=columns, show='headings')
        
        # Define headings
        attack_tree.heading('timestamp', text='Time')
        attack_tree.heading('type', text='Attack Type')
        attack_tree.heading('severity', text='Severity')
        attack_tree.heading('source', text='Source')
        attack_tree.heading('details', text='Details')
        
        # Define columns
        attack_tree.column('timestamp', width=150)
        attack_tree.column('type', width=120)
        attack_tree.column('severity', width=80)
        attack_tree.column('source', width=120)
        attack_tree.column('details', width=250)
        
        # Add scrollbar
        scrollbar = ttk.Scrollbar(list_frame, orient=tk.VERTICAL, command=attack_tree.yview)
        attack_tree.configure(yscroll=scrollbar.set)
        
        # Pack widgets
        attack_tree.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        # Populate attack list
        for attack in self.network_analyzer.attack_history:
            # Format timestamp
            timestamp = datetime.fromisoformat(attack['timestamp']).strftime("%Y-%m-%d %H:%M:%S")
            
            # Get attack name
            attack_name = ATTACK_SIGNATURES.get(attack['type'], {}).get('name', attack['type'])
            
            attack_tree.insert('', tk.END, values=(
                timestamp,
                attack_name,
                attack['severity'],
                attack.get('source_ip', 'Unknown'),
                attack.get('details', '')
            ))
        
        # Add analytics frame if matplotlib is available
        if MATPLOTLIB_AVAILABLE and len(self.network_analyzer.attack_history) >= 2:
            analytics_frame = ttk.LabelFrame(history_window, text="Attack Analytics", padding=10)
            analytics_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
            
            # Create figure
            fig = Figure(figsize=(8, 4), dpi=100)
            
            # Attack frequency over time
            ax = fig.add_subplot(111)
            
            # Extract timestamps and convert to datetime objects
            timestamps = [datetime.fromisoformat(attack['timestamp']) for attack in self.network_analyzer.attack_history]
            attack_types = [attack['type'] for attack in self.network_analyzer.attack_history]
            
            # Count attack types
            attack_counts = Counter(attack_types)
            
            # Create bar chart of attack types
            types = list(attack_counts.keys())
            counts = list(attack_counts.values())
            
            # Map attack types to human-readable names
            type_names = [ATTACK_SIGNATURES.get(t, {}).get('name', t) for t in types]
            
            ax.bar(type_names, counts)
            ax.set_title('Attack Types Frequency')
            ax.set_ylabel('Count')
            ax.set_xlabel('Attack Type')
            
            # Rotate x labels for better readability
            plt.setp(ax.get_xticklabels(), rotation=45, ha='right')
            
            fig.tight_layout()
            
            # Add figure to frame
            canvas = FigureCanvasTkAgg(fig, master=analytics_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
            
        # Add button frame
        button_frame = ttk.Frame(history_window)
        button_frame.pack(fill=tk.X, padx=10, pady=10)
        
        ttk.Button(
            button_frame,
            text="Close",
            command=history_window.destroy
        ).pack(side=tk.RIGHT, padx=5)
        
        ttk.Button(
            button_frame,
            text="Export History",
            command=lambda: self.export_attack_history()
        ).pack(side=tk.RIGHT, padx=5)
    
    def show_network_map(self):
        """Show a visual map of the network"""
        map_window = tk.Toplevel(self.root)
        map_window.title("Network Map")
        map_window.geometry("800x600")
        
        # Create main frame
        main_frame = ttk.Frame(map_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        ttk.Label(
            main_frame,
            text="Network Visualization",
            font=("Arial", 16, "bold")
        ).pack(pady=(0, 10))
        
        if not self.device_list:
            ttk.Label(
                main_frame,
                text="No device data available. Please scan your network first.",
                font=("Arial", 12)
            ).pack(pady=50)
            
            ttk.Button(
                main_frame,
                text="Scan Network Now",
                command=lambda: [map_window.destroy(), self.scan_devices(), self.show_network_map()]
            ).pack()
            
            return
            
        # Use matplotlib to create network visualization if available
        if MATPLOTLIB_AVAILABLE and NUMPY_AVAILABLE:
            # Create figure
            fig = Figure(figsize=(8, 6), dpi=100)
            ax = fig.add_subplot(111)
            
            # Disable axes
            ax.set_axis_off()
            
            # Create router node at center
            router_x, router_y = 0.5, 0.5
            router_color = 'red'
            
            # Create device nodes around router in a circle
            device_count = len(self.device_list)
            radius = 0.35
            device_xs = []
            device_ys = []
            
            for i in range(device_count):
                angle = 2 * np.pi * i / device_count
                x = router_x + radius * np.cos(angle)
                y = router_y + radius * np.sin(angle)
                device_xs.append(x)
                device_ys.append(y)
                
            # Plot router
            ax.scatter(router_x, router_y, color=router_color, s=300, zorder=5, label='Router')
            
            # Plot devices
            ax.scatter(device_xs, device_ys, color='blue', s=200, zorder=4, label='Devices')
            
            # Plot connections from router to devices
            for x, y in zip(device_xs, device_ys):
                ax.plot([router_x, x], [router_y, y], 'k-', alpha=0.5, zorder=1)
                
            # Add labels for devices
            for i, (x, y) in enumerate(zip(device_xs, device_ys)):
                device = self.device_list[i]
                ax.annotate(
                    device['ip'],
                    xy=(x, y),
                    xytext=(0, 10),
                    textcoords='offset points',
                    ha='center',
                    fontsize=8
                )
                
            # Set limits
            ax.set_xlim(0, 1)
            ax.set_ylim(0, 1)
            
            # Add title
            ax.set_title('Network Map')
            
            # Add legend
            ax.legend(loc='upper left')
            
            # Create canvas
            canvas = FigureCanvasTkAgg(fig, master=main_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        else:
            # Create a simple text-based representation
            ttk.Label(
                main_frame,
                text="Network Map (Text Mode - Install matplotlib for visual map)",
                font=("Arial", 12, "bold")
            ).pack(pady=(0, 10))
            
            # Create a frame for the text map
            map_frame = ttk.Frame(main_frame, padding=10)
            map_frame.pack(fill=tk.BOTH, expand=True)
            
            # Router representation
            router_frame = ttk.Frame(map_frame)
            router_frame.pack(pady=20)
            
            ttk.Label(
                router_frame,
                text="ROUTER",
                font=("Arial", 12, "bold"),
                background="light coral",
                padding=10
            ).pack()
            
            ttk.Label(
                router_frame,
                text=self.router_ip.get(),
                font=("Arial", 10)
            ).pack()
            
            # Device representations
            devices_frame = ttk.Frame(map_frame)
            devices_frame.pack(pady=20)
            
            # Layout in a grid
            columns = 3
            for i, device in enumerate(self.device_list):
                device_frame = ttk.Frame(devices_frame, padding=5)
                device_frame.grid(
                    row=i // columns,
                    column=i % columns,
                    padx=10,
                    pady=10
                )
                
                ttk.Label(
                    device_frame,
                    text="DEVICE",
                    font=("Arial", 10, "bold"),
                    background="light blue",
                    padding=5
                ).pack()
                
                ttk.Label(
                    device_frame,
                    text=device['ip'],
                    font=("Arial", 9)
                ).pack()
                
                ttk.Label(
                    device_frame,
                    text=device['mac'],
                    font=("Arial", 8)
                ).pack()
                
        # Add refresh button
        ttk.Button(
            map_window,
            text="Refresh Network Map",
            command=lambda: [map_window.destroy(), self.scan_devices(), self.show_network_map()]
        ).pack(pady=10)
    
    def scan_router_vulnerabilities(self):
        """Scan router for common vulnerabilities"""
        # Start scan window
        scan_window = tk.Toplevel(self.root)
        scan_window.title("Router Vulnerability Scan")
        scan_window.geometry("600x500")
        
        # Create main frame
        main_frame = ttk.Frame(scan_window, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)
        
        # Title
        ttk.Label(
            main_frame,
            text="Router Vulnerability Scanner",
            font=("Arial", 16, "bold")
        ).pack(pady=(0, 20))
        
        # Progress frame
        progress_frame = ttk.Frame(main_frame)
        progress_frame.pack(fill=tk.X, pady=10)
        
        progress_label = ttk.Label(
            progress_frame,
            text="Initializing scan..."
        )
        progress_label.pack(side=tk.LEFT)
        
        progress_bar = ttk.Progressbar(
            progress_frame,
            orient=tk.HORIZONTAL,
            length=400,
            mode='determinate'
        )
        progress_bar.pack(side=tk.RIGHT, fill=tk.X, expand=True, padx=10)
        
        # Results text
        results_frame = ttk.LabelFrame(main_frame, text="Scan Results", padding=10)
        results_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        results_text = scrolledtext.ScrolledText(
            results_frame,
            wrap=tk.WORD,
            height=15,
            font=("Arial", 10)
        )
        results_text.pack(fill=tk.BOTH, expand=True)
        
        # Buttons frame
        buttons_frame = ttk.Frame(main_frame)
        buttons_frame.pack(fill=tk.X, pady=10)
        
        ttk.Button(
            buttons_frame,
            text="Close",
            command=scan_window.destroy
        ).pack(side=tk.RIGHT)
        
        save_button = ttk.Button(
            buttons_frame,
            text="Save Results",
            command=lambda: self.save_scan_results(results_text.get(1.0, tk.END))
        )
        save_button.pack(side=tk.RIGHT, padx=10)
        save_button.config(state=tk.DISABLED)
        
        # Run the scan in a separate thread
        def run_scan():
            router_ip = self.router_ip.get()
            
            # Update UI
            results_text.config(state=tk.NORMAL)
            results_text.delete(1.0, tk.END)
            results_text.insert(tk.END, f"Starting vulnerability scan of router at {router_ip}\n\n")
            results_text.config(state=tk.DISABLED)
            
            # Get router information
            progress_label.config(text="Testing connectivity...")
            progress_bar['value'] = 10
            scan_window.update()
            
            # Test basic connectivity
            ping_result = self.ping_router(router_ip)
            
            if not ping_result['success']:
                results_text.config(state=tk.NORMAL)
                results_text.insert(tk.END, "❌ ERROR: Cannot connect to router. Please check IP address and connectivity.\n")
                results_text.config(state=tk.DISABLED)
                progress_label.config(text="Scan failed")
                return
                
            # Simulate scan of common router vulnerabilities
            vulnerabilities = self.simulate_vulnerability_scan(router_ip)
            
            # Update results
            progress_bar['value'] = 100
            progress_label.config(text="Scan complete")
            
            # Display results
            results_text.config(state=tk.NORMAL)
            
            # Summary
            high_count = sum(1 for v in vulnerabilities if v['severity'] == 'High')
            medium_count = sum(1 for v in vulnerabilities if v['severity'] == 'Medium')
            low_count = sum(1 for v in vulnerabilities if v['severity'] == 'Low')
            
            results_text.insert(tk.END, f"--- SCAN SUMMARY ---\n")
            results_text.insert(tk.END, f"Vulnerabilities found: {len(vulnerabilities)}\n")
            results_text.insert(tk.END, f"  High: {high_count}\n")
            results_text.insert(tk.END, f"  Medium: {medium_count}\n")
            results_text.insert(tk.END, f"  Low: {low_count}\n\n")
            
            # Detailed results
            if vulnerabilities:
                results_text.insert(tk.END, f"--- DETAILED RESULTS ---\n\n")
                
                for i, vuln in enumerate(vulnerabilities, 1):
                    severity_marker = "🔴" if vuln['severity'] == 'High' else (
                        "🟠" if vuln['severity'] == 'Medium' else "🟡"
                    )
                    
                    results_text.insert(tk.END, f"{severity_marker} {vuln['name']}\n")
                    results_text.insert(tk.END, f"   Severity: {vuln['severity']}\n")
                    results_text.insert(tk.END, f"   Description: {vuln['description']}\n")
                    results_text.insert(tk.END, f"   Recommendation: {vuln['recommendation']}\n")
                    
                    # Add Bangladesh-specific note if available
                    if 'bd_note' in vuln and vuln['bd_note']:
                        results_text.insert(tk.END, f"   Bangladesh Context: {vuln['bd_note']}\n")
                        
                    results_text.insert(tk.END, "\n")
            else:
                results_text.insert(tk.END, "No vulnerabilities found. Your router appears to be secure.\n")
                
            results_text.config(state=tk.DISABLED)
            
            # Enable save button
            save_button.config(state=tk.NORMAL)
            
        threading.Thread(target=run_scan).start()
        
    def simulate_vulnerability_scan(self, router_ip):
        """Simulate scanning router for vulnerabilities"""
        # This is a simulation for demonstration
        # In a real implementation, this would perform actual tests
        
        # Get the ISP info for contextual vulnerabilities
        isp_info = self.network_analyzer.isp_data['info']
        
        # List of simulated vulnerabilities
        vulnerabilities = []
        
        # Simulate common router issues
        
        # 1. Test for default credentials (high risk in Bangladesh)
        if "Default admin passwords" in isp_info['known_vulnerabilities']:
            vulnerabilities.append({
                'name': 'Default Admin Credentials',
                'severity': 'High',
                'description': 'Router may be using default manufacturer credentials which are publicly known.',
                'recommendation': 'Change admin password immediately. Use a strong, unique password.',
                'bd_note': 'Default credentials are a common attack vector in Bangladesh, especially for ISP-provided routers.'
            })
            
        # 2. Test for outdated firmware
        if "Outdated firmware" in isp_info['known_vulnerabilities']:
            vulnerabilities.append({
                'name': 'Outdated Firmware',
                'severity': 'High',
                'description': 'Router firmware has known security vulnerabilities that have been patched in newer versions.',
                'recommendation': 'Update router firmware to the latest version from the manufacturer website.',
                'bd_note': 'Many routers in Bangladesh run outdated firmware due to lack of automatic updates.'
            })
            
        # 3. Test for open ports (randomly determine if found)
        if random.random() < 0.4:
            vulnerabilities.append({
                'name': 'Unnecessary Open Ports',
                'severity': 'Medium',
                'description': 'Several ports are open on your router that are not required for normal operation.',
                'recommendation': 'Close unnecessary ports through router firewall settings.',
                'bd_note': 'Open ports are frequently scanned by attackers in Bangladesh.'
            })
            
        # 4. Test for UPnP vulnerability
        if random.random() < 0.3:
            vulnerabilities.append({
                'name': 'UPnP Enabled',
                'severity': 'Medium',
                'description': 'Universal Plug and Play (UPnP) is enabled, which can allow unauthorized port forwarding.',
                'recommendation': 'Disable UPnP in router settings unless specifically needed.',
                'bd_note': 'UPnP vulnerabilities have been exploited in recent attacks in Bangladesh.'
            })
            
        # 5. Test for WPS vulnerability (common in BD)
        if random.random() < 0.5:
            vulnerabilities.append({
                'name': 'WPS Enabled',
                'severity': 'High',
                'description': 'WiFi Protected Setup (WPS) is enabled and vulnerable to brute force attacks.',
                'recommendation': 'Disable WPS in router settings.',
                'bd_note': 'WPS attacks are common in urban areas of Bangladesh.'
            })
            
        # 6. Test for weak WiFi encryption
        if random.random() < 0.3:
            vulnerabilities.append({
                'name': 'Weak WiFi Encryption',
                'severity': 'High',
                'description': 'Router is using outdated WEP or WPA encryption instead of WPA2/WPA3.',
                'recommendation': 'Update WiFi security settings to use WPA2-PSK (AES) or WPA3 if available.',
                'bd_note': 'WiFi cracking tools are widely available in Bangladesh.'
            })
            
        # 7. Test for remote administration
        if random.random() < 0.4:
            vulnerabilities.append({
                'name': 'Remote Administration Enabled',
                'severity': 'Medium',
                'description': 'Router allows administration from the internet, increasing attack surface.',
                'recommendation': 'Disable remote administration unless absolutely necessary.',
                'bd_note': None
            })
            
        # 8. Test for DNS vulnerabilities
        if random.random() < 0.3:
            vulnerabilities.append({
                'name': 'Vulnerable DNS Configuration',
                'severity': 'Medium',
                'description': 'Router uses DNS servers that may be vulnerable to poisoning or hijacking.',
                'recommendation': 'Change DNS settings to use secure DNS servers like 1.1.1.1 or 8.8.8.8.',
                'bd_note': 'DNS hijacking has been reported in Bangladesh in recent months.'
            })
            
        # 9. DHCP configuration issues
        if random.random() < 0.2:
            vulnerabilities.append({
                'name': 'Insecure DHCP Configuration',
                'severity': 'Low',
                'description': 'DHCP server may assign addresses to unknown devices without restrictions.',
                'recommendation': 'Configure MAC address filtering or set static IP addresses for known devices.',
                'bd_note': None
            })
            
        # 10. Test for exposed services (Telnet, FTP, etc.)
        if random.random() < 0.3:
            vulnerabilities.append({
                'name': 'Exposed Management Services',
                'severity': 'High',
                'description': 'Telnet, FTP, or other unencrypted management services are enabled on the router.',
                'recommendation': 'Disable Telnet and FTP, use SSH and SFTP instead if remote access is needed.',
                'bd_note': 'Telnet scanning is very common in Bangladesh networks.'
            })
            
        # Simulate scanning delay
        for i in range(1, 10):
            time.sleep(0.5)
            
        return vulnerabilities
        
    def save_scan_results(self, results):
        """Save vulnerability scan results to a file"""
        try:
            # Ask for save location
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                title="Save Scan Results"
            )
            
            if not file_path:
                return
                
            # Save results
            with open(file_path, 'w') as file:
                file.write("NETGUARD BANGLADESH - ROUTER VULNERABILITY SCAN\n")
                file.write("=============================================\n\n")
                file.write(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                file.write(f"Router IP: {self.router_ip.get()}\n")
                file.write(f"ISP: {self.network_analyzer.isp_data['name']}\n\n")
                file.write(results)
                
            messagebox.showinfo(
                "Save Successful",
                f"Scan results saved to:\n{file_path}"
            )
            
        except Exception as e:
            messagebox.showerror(
                "Save Error",
                f"Failed to save scan results: {str(e)}"
            )
            
    def show_network_devices(self):
        """Show detailed information about network devices"""
        # Implemented in full code
        pass
        
    def guess_manufacturer(self, mac):
        """Guess manufacturer from MAC address OUI"""
        # Implemented in full code
        pass
        
    def estimate_device_risk(self, device_type, mac):
        """Estimate security risk level of a device"""
        # Implemented in full code
        pass
        
    def run_speed_test(self):
        """Run internet speed test"""
        # Implemented in full code
        pass
        
    def start_speed_test(self, status_label, progress_bar, download_value, upload_value, ping_value, start_button):
        """Run the speed test"""
        # Implemented in full code
        pass
        
    def simulate_ping_test(self):
        """Simulate ping test"""
        # Implemented in full code
        pass
        
    def simulate_download_test(self, progress_callback):
        """Simulate download speed test"""
        # Implemented in full code
        pass
        
    def simulate_upload_test(self, progress_callback):
        """Simulate upload speed test"""
        # Implemented in full code
        pass
        
    def show_preferences(self):
        """Show and edit application preferences"""
        # Implemented in full code
        pass
        
    def save_preferences(self, scan_interval, alert_level, dark_mode, sound_alerts, window):
        """Save updated preferences"""
        # Implemented in full code
        pass
        
    def show_alert_settings(self):
        """Show advanced alert settings"""
        # Implemented in full code
        pass
        
    def show_tutorial(self):
        """Show application tutorial"""
        # Implemented in full code
        pass
        
    def show_bd_security_info(self):
        """Show Bangladesh-specific network security information"""
        # Implemented in full code
        pass
        
    def show_about(self):
        """Show about dialog"""
        # Implemented in full code
        pass
        
    def on_close(self):
        """Handle application closing"""
        if self.is_monitoring.get():
            result = messagebox.askyesno(
                "Confirm Exit",
                "Security monitoring is active. Are you sure you want to exit?"
            )
            
            if not result:
                return
                
            self.is_monitoring.set(False)
            # Wait a moment for monitoring thread to stop
            time.sleep(0.5)
            
        self.root.destroy()


def main():
    # Check for required directories
    if not os.path.exists(DATA_DIR):
        os.makedirs(DATA_DIR)
        
    # Set up high DPI awareness
    if platform.system() == "Windows":
        try:
            from ctypes import windll
            windll.shcore.SetProcessDpiAwareness(1)
        except:
            pass
            
    # Create root window
    root = tk.Tk()
    
    # Create app
    try:
        app = NetGuardBangladesh(root)
        root.mainloop()
    except Exception as e:
        logger.critical(f"Application crashed: {str(e)}")
        
        # Show error
        messagebox.showerror(
            "Application Error",
            f"The application encountered a critical error and needs to close.\n\nError: {str(e)}\n\nPlease check the log file for details."
        )
        
        raise

if __name__ == "__main__":
    main()
